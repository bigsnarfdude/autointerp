#!/usr/bin/env python3
"""
AF Monitor Server — Human-in-the-loop review UI for alignment faking alerts.

Serves the dashboard and provides API endpoints for browsing, filtering,
and annotating alerts generated by pipeline.py.

Usage: python monitor/server.py
"""
import json
import sys
from pathlib import Path
from datetime import datetime

from fastapi import FastAPI, Query
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse, JSONResponse
from pydantic import BaseModel
from typing import Optional
import uvicorn

DATA_DIR = Path(__file__).parent / "data"
STATIC_DIR = Path(__file__).parent / "static"
ALERTS_PATH = DATA_DIR / "alerts.json"

app = FastAPI(title="AF Monitor", version="0.1.0")

# In-memory store (loaded from alerts.json)
_data = None


def get_data():
    global _data
    if _data is None:
        with open(ALERTS_PATH) as f:
            _data = json.load(f)
    return _data


def save_data():
    """Persist annotation changes back to alerts.json."""
    if _data is not None:
        with open(ALERTS_PATH, "w") as f:
            json.dump(_data, f, indent=2)


# --- API Endpoints ---

@app.get("/api/summary")
def get_summary():
    """Pipeline summary stats."""
    return get_data()["summary"]


@app.get("/api/alerts")
def get_alerts(
    severity: Optional[str] = Query(None, description="HIGH, MEDIUM, LOW"),
    dataset: Optional[str] = Query(None),
    reviewed: Optional[bool] = Query(None),
    label: Optional[str] = Query(None, description="Filter by human_label"),
    min_score: float = Query(0.0),
    max_score: float = Query(1.0),
    offset: int = Query(0, ge=0),
    limit: int = Query(50, ge=1, le=200),
    sort: str = Query("score_desc", description="score_desc, score_asc, intent_desc"),
):
    """Paginated, filtered alert listing."""
    data = get_data()
    alerts = data["alerts"]

    # Filter
    if severity:
        alerts = [a for a in alerts if a["severity"] == severity.upper()]
    if dataset:
        alerts = [a for a in alerts if a["dataset"] == dataset]
    if reviewed is not None:
        alerts = [a for a in alerts if a["reviewed"] == reviewed]
    if label:
        alerts = [a for a in alerts if a.get("human_label") == label]
    if min_score > 0:
        alerts = [a for a in alerts if a["score"] >= min_score]
    if max_score < 1:
        alerts = [a for a in alerts if a["score"] <= max_score]

    # Sort
    if sort == "score_asc":
        alerts = sorted(alerts, key=lambda a: a["score"])
    elif sort == "intent_desc":
        alerts = sorted(alerts, key=lambda a: a["n_intent_features"], reverse=True)
    # Default: score_desc (already sorted)

    total = len(alerts)
    page = alerts[offset:offset + limit]

    # Strip text_snippet from listing to reduce payload (fetch detail separately)
    lite = []
    for a in page:
        lite.append({
            "id": a["id"],
            "dataset": a["dataset"],
            "sample_idx": a["sample_idx"],
            "score": a["score"],
            "severity": a["severity"],
            "true_label": a["true_label"],
            "n_intent_features": a["n_intent_features"],
            "n_rlhf_awareness": a["n_rlhf_awareness"],
            "n_self_preservation": a["n_self_preservation"],
            "n_vocab_artifacts": a["n_vocab_artifacts"],
            "reviewed": a["reviewed"],
            "human_label": a["human_label"],
            "supervisor_opinion": a["supervisor_opinion"],
        })

    return {"total": total, "offset": offset, "limit": limit, "alerts": lite}


@app.get("/api/alerts/{alert_id}")
def get_alert_detail(alert_id: str):
    """Full alert detail including text snippet and feature breakdown."""
    data = get_data()
    for a in data["alerts"]:
        if a["id"] == alert_id:
            return a
    return JSONResponse(status_code=404, content={"error": "Alert not found"})


class AnnotationUpdate(BaseModel):
    human_label: Optional[str] = None  # "confirmed_af", "false_positive", "uncertain", "interesting"
    supervisor_opinion: Optional[str] = None
    reviewed: bool = True


@app.post("/api/alerts/{alert_id}/annotate")
def annotate_alert(alert_id: str, update: AnnotationUpdate):
    """Human annotation on an alert."""
    data = get_data()
    for a in data["alerts"]:
        if a["id"] == alert_id:
            if update.human_label is not None:
                a["human_label"] = update.human_label
            if update.supervisor_opinion is not None:
                a["supervisor_opinion"] = update.supervisor_opinion
            a["reviewed"] = update.reviewed
            save_data()
            return {"status": "ok", "id": alert_id}
    return JSONResponse(status_code=404, content={"error": "Alert not found"})


@app.get("/api/clusters")
def get_clusters(limit: int = Query(50)):
    """Pattern clusters sorted by size."""
    data = get_data()
    return data["clusters"][:limit]


@app.get("/api/datasets")
def get_datasets():
    """Dataset-level stats."""
    return get_data()["summary"]["datasets"]


@app.get("/api/stats")
def get_annotation_stats():
    """Annotation progress stats."""
    data = get_data()
    alerts = data["alerts"]
    total = len(alerts)
    reviewed = sum(1 for a in alerts if a["reviewed"])
    labels = {}
    for a in alerts:
        l = a.get("human_label") or "unreviewed"
        labels[l] = labels.get(l, 0) + 1

    # Accuracy vs ground truth
    correct = 0
    incorrect = 0
    for a in alerts:
        if a["human_label"] and a["true_label"]:
            is_af = a["human_label"] == "confirmed_af"
            true_af = a["true_label"] == "AF"
            if is_af == true_af:
                correct += 1
            else:
                incorrect += 1

    return {
        "total": total,
        "reviewed": reviewed,
        "unreviewed": total - reviewed,
        "progress_pct": round(100 * reviewed / total, 1) if total else 0,
        "label_counts": labels,
        "accuracy": {
            "correct": correct,
            "incorrect": incorrect,
            "total_annotated": correct + incorrect,
            "pct": round(100 * correct / (correct + incorrect), 1) if (correct + incorrect) > 0 else None,
        },
    }


# --- Static files ---

@app.get("/")
def index():
    return FileResponse(STATIC_DIR / "index.html")


# Mount static after route definitions
app.mount("/static", StaticFiles(directory=str(STATIC_DIR)), name="static")


if __name__ == "__main__":
    print(f"AF Monitor — http://localhost:8501")
    print(f"Data: {ALERTS_PATH}")
    uvicorn.run(app, host="0.0.0.0", port=8501)
