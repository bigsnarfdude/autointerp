<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>AF Storytelling Explorer</title>
<style>
/* === Reset & Base === */
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

:root {
    --bg: #F3EDE3;
    --accent: #8B9D83;
    --accent-hover: #7A8C73;
    --accent-light: rgba(139, 157, 131, 0.15);
    --panel: #FFFFFF;
    --panel-shadow: 0 8px 32px rgba(0,0,0,0.08);
    --panel-radius: 12px;
    --border: #E0E0E0;
    --text: #2A2A2A;
    --text-secondary: #666666;
    --text-muted: #999999;
    --hover-bg: #F5F5F5;
    --canvas-bg: #F3EDE3;
    --font: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', sans-serif;
    --mono: 'Consolas', 'Monaco', 'SF Mono', monospace;
}

[data-theme="dark"] {
    --bg: #1a1a1a;
    --accent: #8B9D83;
    --accent-hover: #9DB094;
    --accent-light: rgba(139, 157, 131, 0.2);
    --panel: #242424;
    --panel-shadow: 0 8px 32px rgba(0,0,0,0.3);
    --border: #3a3a3a;
    --text: #e0e0e0;
    --text-secondary: #aaaaaa;
    --text-muted: #777777;
    --hover-bg: #2e2e2e;
    --canvas-bg: #1a1a1a;
}

html, body {
    height: 100%;
    overflow: hidden;
    font-family: var(--font);
    color: var(--text);
    background: var(--bg);
}

/* === Layout === */
.app { display: flex; height: 100vh; gap: 0; }

.main-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-width: 0;
}

.toolbar {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 20px;
    background: var(--panel);
    backdrop-filter: blur(8px);
    border-bottom: 1px solid var(--border);
    z-index: 10;
    flex-wrap: wrap;
}

.toolbar h1 { font-size: 14px; font-weight: 600; white-space: nowrap; }
.toolbar .sep { width: 1px; height: 20px; background: var(--border); }

.search-wrap { position: relative; flex: 0 1 280px; }

.search-wrap input {
    width: 100%;
    padding: 7px 12px;
    border: 1px solid var(--border);
    border-radius: 8px;
    font-size: 13px;
    background: var(--panel);
    color: var(--text);
    transition: border-color 0.15s;
}

.search-wrap input:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(139,157,131,0.1);
}

.search-status { font-size: 11px; color: var(--text-muted); white-space: nowrap; }

.toolbar-stats {
    margin-left: auto;
    font-size: 11px;
    color: var(--text-secondary);
    white-space: nowrap;
}

/* === Canvas === */
.canvas-container { flex: 1; position: relative; overflow: hidden; }

canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }

/* Tooltip */
.tooltip {
    position: fixed;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 8px 12px;
    font-size: 12px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.1);
    pointer-events: none;
    z-index: 100;
    max-width: 300px;
    display: none;
}

.tooltip .tt-idx { font-weight: 600; color: var(--accent); }
.tooltip .tt-interp { color: var(--text); font-weight: 400; font-style: italic; margin-top: 2px; }
.tooltip .tt-stats { color: var(--text-secondary); margin-top: 2px; }
.tooltip .tt-cat { display: inline-block; padding: 1px 6px; border-radius: 3px; font-size: 10px; color: white; margin-top: 3px; }

/* === Sidebar === */
.sidebar {
    width: 420px;
    background: var(--panel);
    border-left: 1px solid var(--border);
    box-shadow: var(--panel-shadow);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    transition: width 0.2s ease;
}

.sidebar.collapsed { width: 0; border-left: none; }

.sidebar-header {
    padding: 16px 20px 12px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.sidebar-header .label {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.03em;
    color: var(--text);
    opacity: 0.7;
}

.sidebar-close {
    background: none;
    border: none;
    font-size: 18px;
    color: var(--text-muted);
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
    line-height: 1;
}

.sidebar-close:hover { background: var(--hover-bg); color: var(--text-secondary); }

.sidebar-body {
    flex: 1;
    overflow-y: auto;
    padding: 16px 20px;
}

.sidebar-body::-webkit-scrollbar { width: 8px; }
.sidebar-body::-webkit-scrollbar-track { background: transparent; }
.sidebar-body::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
.sidebar-body::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

.feature-title { font-size: 20px; font-weight: 700; margin-bottom: 4px; }
.feature-title .idx { color: var(--accent); }

/* Interp edit box */
.interp-box { display: flex; gap: 6px; margin-top: 8px; margin-bottom: 12px; }

.interp-input {
    flex: 1;
    padding: 8px 12px;
    font-family: var(--font);
    font-size: 14.5px;
    font-weight: 600;
    font-style: italic;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--hover-bg);
    color: var(--text);
    outline: none;
}

.interp-input:focus { border-color: var(--accent); }

.interp-save {
    padding: 6px 12px;
    font-size: 12px;
    font-family: var(--font);
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    white-space: nowrap;
}

.interp-save:hover { background: var(--accent-hover); }
.interp-save:disabled { opacity: 0.5; cursor: not-allowed; }

/* Stats grid */
.stats-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin: 12px 0 16px;
}

.stat-card { background: var(--hover-bg); border-radius: 8px; padding: 10px 12px; }
.stat-label { font-size: 10px; text-transform: uppercase; letter-spacing: 0.04em; color: var(--text-muted); margin-bottom: 2px; }
.stat-value { font-size: 15px; font-weight: 600; font-family: var(--mono); }

/* Examples */
.examples-header {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.03em;
    color: var(--text);
    opacity: 0.7;
    margin: 16px 0 8px;
}

.example {
    background: var(--hover-bg);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 8px;
    font-family: var(--mono);
    font-size: 12px;
    line-height: 1.7;
    word-break: break-word;
    border-left: 3px solid transparent;
}

.example .peak { font-size: 10px; color: var(--text-muted); margin-bottom: 6px; font-family: var(--font); }

.tok { padding: 1px 0; border-radius: 2px; white-space: pre-wrap; }
.tok.hot {
    background: rgba(139, 157, 131, var(--intensity));
    border-bottom: 2px solid rgba(139, 157, 131, calc(var(--intensity) * 1.5));
}

.empty-state {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    height: 100%; color: var(--text-muted); text-align: center; padding: 40px;
}

.empty-state .icon { font-size: 40px; margin-bottom: 12px; opacity: 0.3; }
.empty-state p { font-size: 13px; line-height: 1.6; }

.loading { text-align: center; padding: 40px; color: var(--text-muted); }
.spinner {
    display: inline-block; width: 20px; height: 20px;
    border: 2px solid var(--border); border-top-color: var(--accent);
    border-radius: 50%; animation: spin 0.6s linear infinite; margin-bottom: 8px;
}
@keyframes spin { to { transform: rotate(360deg); } }

/* Search results */
.search-results { margin-top: 8px; }

.search-result-item {
    display: flex; flex-wrap: wrap; align-items: center; gap: 4px 8px;
    padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;
    transition: background 0.1s;
}

.search-result-item:hover { background: var(--hover-bg); }
.search-result-item .feat-idx { font-family: var(--mono); font-weight: 600; color: var(--accent); }
.search-result-item .feat-score { font-family: var(--mono); color: var(--text-muted); font-size: 11px; margin-left: auto; }
.search-result-item .feat-bar { width: 100%; height: 4px; background: var(--border); border-radius: 2px; overflow: hidden; }
.search-result-item .feat-bar-fill { height: 100%; background: var(--accent); border-radius: 2px; }

/* Toggle button */
.infer-toggle {
    padding: 4px 10px;
    border: 1px solid var(--border);
    border-radius: 6px;
    font-size: 11px;
    cursor: pointer;
    background: transparent;
    color: var(--text-secondary);
    transition: all 0.15s;
}

.infer-toggle.active { background: var(--accent); color: white; border-color: var(--accent); }

/* === Story Panel === */
.story-panel {
    position: absolute;
    top: 20px;
    left: 20px;
    width: 360px;
    max-height: calc(100vh - 140px);
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    box-shadow: var(--panel-shadow);
    z-index: 50;
    display: none;
    flex-direction: column;
    overflow: hidden;
}

.story-panel.visible { display: flex; }

.story-header {
    padding: 16px 20px 12px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.story-header .chapter-label {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--accent);
}

.story-header .story-close {
    background: none;
    border: none;
    font-size: 18px;
    color: var(--text-muted);
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
    line-height: 1;
}

.story-body {
    flex: 1;
    overflow-y: auto;
    padding: 16px 20px;
}

.story-body h2 { font-size: 18px; font-weight: 700; margin-bottom: 4px; }
.story-body .subtitle { font-size: 12px; color: var(--text-secondary); margin-bottom: 12px; }
.story-body .narrative { font-size: 13px; line-height: 1.65; color: var(--text); }
.story-body .narrative p { margin-bottom: 10px; }
.story-body .narrative strong { color: var(--accent); }

.story-nav {
    display: flex;
    gap: 8px;
    padding: 12px 20px;
    border-top: 1px solid var(--border);
}

.story-nav button {
    flex: 1;
    padding: 8px;
    border: 1px solid var(--border);
    border-radius: 8px;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    background: var(--hover-bg);
    color: var(--text);
    transition: all 0.15s;
}

.story-nav button:hover { background: var(--accent); color: white; border-color: var(--accent); }
.story-nav button:disabled { opacity: 0.3; cursor: not-allowed; }
.story-nav button:disabled:hover { background: var(--hover-bg); color: var(--text); border-color: var(--border); }

/* Chapter dots */
.story-dots {
    display: flex;
    justify-content: center;
    gap: 6px;
    padding: 8px 0 4px;
}

.story-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--border);
    cursor: pointer;
    transition: all 0.2s;
}

.story-dot.active { background: var(--accent); transform: scale(1.3); }

/* === Category Legend === */
.legend-panel {
    position: absolute;
    bottom: 20px;
    left: 20px;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 10px;
    box-shadow: var(--panel-shadow);
    z-index: 40;
    padding: 12px 16px;
    display: none;
    max-width: 280px;
}

.legend-panel.visible { display: block; }
.legend-panel h3 { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.04em; color: var(--text-muted); margin-bottom: 8px; }

.legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 3px 4px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    transition: background 0.1s;
}

.legend-item:hover { background: var(--hover-bg); }
.legend-item .dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
.legend-item .cat-label { flex: 1; }
.legend-item .cat-count { font-family: var(--mono); font-size: 10px; color: var(--text-muted); }

/* === Sample Viewer === */
.sample-panel {
    position: absolute;
    bottom: 20px;
    right: 440px;
    width: 360px;
    max-height: 400px;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    box-shadow: var(--panel-shadow);
    z-index: 40;
    display: none;
    flex-direction: column;
    overflow: hidden;
}

.sample-panel.visible { display: flex; }

.sample-header {
    padding: 12px 16px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.sample-body { flex: 1; overflow-y: auto; padding: 12px 16px; font-size: 12px; }

.severity-badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 10px;
    font-weight: 700;
    color: white;
}

.severity-HIGH { background: #e74c3c; }
.severity-MEDIUM { background: #e67e22; }
.severity-LOW { background: #f1c40f; color: #333; }

/* Category badge */
.cat-badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 10px;
    font-weight: 600;
    color: white;
    margin-right: 4px;
    margin-bottom: 4px;
}

/* Category breakdown bar */
.cat-breakdown {
    display: flex;
    height: 8px;
    border-radius: 4px;
    overflow: hidden;
    margin: 8px 0;
}

/* Proximity labels for 3D */
.proximity-label {
    position: absolute;
    pointer-events: none;
    font-family: var(--mono);
    color: rgba(255, 255, 255, 0.9);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 4px;
    padding: 2px 6px;
    white-space: nowrap;
    transform-origin: left center;
}
.proximity-label .pl-idx { font-weight: 600; color: var(--accent); }
.proximity-label .pl-interp { font-style: italic; opacity: 0.85; }
.proximity-label .pl-stats { color: rgba(255,255,255,0.5); }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div class="app">
    <div class="main-area">
        <div class="toolbar">
            <h1>AF Storytelling Explorer</h1>
            <div class="sep"></div>
            <div class="search-wrap">
                <input type="text" id="search" placeholder="Search descriptions (e.g. self preservation, compliance)..." spellcheck="false">
            </div>
            <span class="search-status" id="search-status"></span>
            <select id="color-mode" style="font-size:11px;background:var(--panel);color:var(--text);border:1px solid var(--border);border-radius:4px;padding:3px 6px">
                <option value="category" selected>Category</option>
                <option value="scheming">Scheming Score</option>
                <option value="probe">Probe Weight</option>
                <option value="af_fraction">AF Fraction</option>
                <option value="act+density">Act + Density</option>
                <option value="mean">Mean Activation</option>
                <option value="max">Max Activation</option>
                <option value="density">Density</option>
                <option value="position">Position</option>
            </select>
            <button class="infer-toggle" id="story-toggle" title="Guided story tour">Story</button>
            <button class="infer-toggle" id="sample-toggle" title="Sample alert viewer">Samples</button>
            <button class="infer-toggle" id="view-toggle" title="Toggle 2D/3D UMAP">3D</button>
            <label style="display:flex;align-items:center;gap:4px;font-size:11px;color:var(--text-secondary)" title="Spread points apart">
                Spread <input type="range" id="spread-slider" min="0.5" max="4" step="0.1" value="1" style="width:60px;height:14px">
                <span id="spread-val" style="font-family:var(--mono);min-width:24px">1.0</span>
            </label>
            <label style="display:flex;align-items:center;gap:4px;font-size:11px;color:var(--text-secondary)" title="Glow intensity">
                Glow <input type="range" id="glow-slider" min="0" max="1000" value="100" style="width:60px;height:14px">
                <span id="glow-val" style="font-family:var(--mono);min-width:28px">1.0</span>
            </label>
            <button class="infer-toggle" id="theme-toggle" title="Toggle dark mode">Dark</button>
            <span class="toolbar-stats" id="toolbar-stats">Loading...</span>
        </div>
        <div class="canvas-container" id="canvas-container">
            <canvas id="umap"></canvas>
            <div id="three-container" style="display:none;position:absolute;top:0;left:0;width:100%;height:100%"></div>
            <canvas id="proximity-lines" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none"></canvas>
            <div id="proximity-labels" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;overflow:hidden"></div>
            <!-- Story panel -->
            <div class="story-panel" id="story-panel">
                <div class="story-header">
                    <span class="chapter-label" id="story-chapter-label">Chapter 1 of 6</span>
                    <button class="story-close" id="story-close">&times;</button>
                </div>
                <div class="story-body" id="story-body"></div>
                <div class="story-dots" id="story-dots"></div>
                <div class="story-nav">
                    <button id="story-prev" disabled>Previous</button>
                    <button id="story-next">Next</button>
                </div>
            </div>
            <!-- Category legend -->
            <div class="legend-panel" id="legend-panel">
                <h3>Categories</h3>
                <div id="legend-items"></div>
            </div>
            <!-- Sample viewer -->
            <div class="sample-panel" id="sample-panel">
                <div class="sample-header">
                    <span style="font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:0.04em;color:var(--text-muted)">Alert Sample</span>
                    <div style="display:flex;gap:6px">
                        <button class="infer-toggle" id="sample-prev" style="padding:2px 8px">&lt;</button>
                        <span id="sample-idx" style="font-size:11px;font-family:var(--mono);color:var(--text-muted);min-width:40px;text-align:center;line-height:24px">1/20</span>
                        <button class="infer-toggle" id="sample-next" style="padding:2px 8px">&gt;</button>
                    </div>
                </div>
                <div class="sample-body" id="sample-body"></div>
            </div>
        </div>
    </div>

    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <span class="label">Feature Detail</span>
            <button class="sidebar-close" id="sidebar-close">&times;</button>
        </div>
        <div class="sidebar-body" id="sidebar-body">
            <div class="empty-state">
                <div class="icon">&#x25CF;</div>
                <p>Click a point on the UMAP to inspect a feature.<br>
                Use the search bar to find features by description.<br>
                Click <strong>Story</strong> for a guided tour.</p>
            </div>
        </div>
    </div>
</div>

<div class="tooltip" id="tooltip"></div>

<script>
// === State ===
let features = [];
let meta = {};
let colorMode = "category";
let selectedIdx = null;
let highlightSet = null;
let searchResults = null;
let categoryData = [];
let categoryColorMap = {};
let storyData = [];
let storyChapter = 0;
let samplesData = [];
let sampleIdx = 0;
let probeWeightSizing = false;

// View transform
let viewX = 0, viewY = 0, viewScale = 1;
let dataXMin, dataXMax, dataYMin, dataYMax;

const canvas = document.getElementById("umap");
const ctx = canvas.getContext("2d");
const tooltip = document.getElementById("tooltip");
const sidebar = document.getElementById("sidebar");
const sidebarBody = document.getElementById("sidebar-body");
const searchInput = document.getElementById("search");
const searchStatus = document.getElementById("search-status");
const toolbarStats = document.getElementById("toolbar-stats");

// === Feature labels ===
let featureLabels = {};

// === Data loading ===
async function init() {
    const [resp, labelsResp, catResp, storyResp, samplesResp] = await Promise.all([
        fetch("/static/feature_data.json"),
        fetch("/api/labels"),
        fetch("/api/categories"),
        fetch("/api/story"),
        fetch("/api/samples"),
    ]);
    const data = await resp.json();
    featureLabels = await labelsResp.json();
    categoryData = await catResp.json();
    storyData = await storyResp.json();
    samplesData = await samplesResp.json();

    features = data.features;
    meta = data.meta;

    // Build category color map
    for (const cat of categoryData) {
        categoryColorMap[cat.id] = cat.color;
    }

    // Store original coordinates
    for (const f of features) {
        f._ox = f.x; f._oy = f.y;
        if (f.x3 !== undefined) { f._ox3 = f.x3; f._oy3 = f.y3; f._oz3 = f.z3; }
    }

    // Precompute percentile ranks
    const byDensity = features.slice().sort((a, b) => a.d - b.d);
    const byMean = features.slice().sort((a, b) => a.mn - b.mn);
    const byMax = features.slice().sort((a, b) => a.mx - b.mx);
    const n = features.length;
    for (let i = 0; i < n; i++) {
        byDensity[i]._rd = i / (n - 1);
        byMean[i]._rm = i / (n - 1);
        byMax[i]._rx = i / (n - 1);
    }

    applySpread(parseFloat(document.getElementById("spread-slider").value));
    computeBounds();

    const nScheming = features.filter(f => f.cat && f.cat !== "unclassified").length;
    toolbarStats.textContent = `${meta.n_features.toLocaleString()} features | ${nScheming.toLocaleString()} scheming | Layer ${meta.layer}`;

    buildLegend();
    resize();
    resetView();
    draw();
}

// === Category Legend ===
function buildLegend() {
    const el = document.getElementById("legend-items");
    el.innerHTML = "";
    for (const cat of categoryData) {
        if (cat.count === 0) continue;
        const item = document.createElement("div");
        item.className = "legend-item";
        item.innerHTML = `<div class="dot" style="background:${cat.color}"></div><span class="cat-label">${cat.label}</span><span class="cat-count">${cat.count}</span>`;
        item.addEventListener("click", () => {
            // Highlight all features in this category
            highlightSet = new Set(features.filter(f => f.cat === cat.id).map(f => f.i));
            draw();
            searchStatus.textContent = `${highlightSet.size} features: ${cat.label}`;
        });
        el.appendChild(item);
    }
}

// Show legend when in category color mode
function updateLegendVisibility() {
    const panel = document.getElementById("legend-panel");
    if (colorMode === "category" || colorMode === "scheming" || colorMode === "af_fraction") {
        panel.classList.add("visible");
    } else {
        panel.classList.remove("visible");
    }
}

// === Spread ===
let spreadValue = 1.0;

function applySpread(s) {
    spreadValue = s;
    if (features.length === 0) return;

    let cx2 = 0, cy2 = 0;
    for (const f of features) { cx2 += f._ox; cy2 += f._oy; }
    cx2 /= features.length; cy2 /= features.length;

    for (const f of features) {
        const dx = f._ox - cx2;
        const dy = f._oy - cy2;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 1e-8) { f.x = f._ox; f.y = f._oy; continue; }
        const scaled = Math.pow(dist, s);
        const ratio = scaled / dist;
        f.x = cx2 + dx * ratio;
        f.y = cy2 + dy * ratio;
    }

    if (features[0]._ox3 !== undefined) {
        let cx3 = 0, cy3 = 0, cz3 = 0;
        for (const f of features) { cx3 += f._ox3; cy3 += f._oy3; cz3 += f._oz3; }
        cx3 /= features.length; cy3 /= features.length; cz3 /= features.length;

        for (const f of features) {
            const dx = f._ox3 - cx3;
            const dy = f._oy3 - cy3;
            const dz = f._oz3 - cz3;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            if (dist < 1e-8) { f.x3 = f._ox3; f.y3 = f._oy3; f.z3 = f._oz3; continue; }
            const scaled = Math.pow(dist, s);
            const ratio = scaled / dist;
            f.x3 = cx3 + dx * ratio;
            f.y3 = cy3 + dy * ratio;
            f.z3 = cz3 + dz * ratio;
        }
    }
}

function computeBounds() {
    dataXMin = Infinity; dataXMax = -Infinity;
    dataYMin = Infinity; dataYMax = -Infinity;
    for (const f of features) {
        if (f.x < dataXMin) dataXMin = f.x;
        if (f.x > dataXMax) dataXMax = f.x;
        if (f.y < dataYMin) dataYMin = f.y;
        if (f.y > dataYMax) dataYMax = f.y;
    }
    const padX = (dataXMax - dataXMin) * 0.05;
    const padY = (dataYMax - dataYMin) * 0.05;
    dataXMin -= padX; dataXMax += padX;
    dataYMin -= padY; dataYMax += padY;
}

// Spread slider
const spreadSlider = document.getElementById("spread-slider");
const spreadVal = document.getElementById("spread-val");
spreadSlider.addEventListener("input", () => {
    const s = parseFloat(spreadSlider.value);
    spreadVal.textContent = s.toFixed(1);
    applySpread(s);
    computeBounds();
    if (viewMode === "2d") { resetView(); draw(); }
    else if (threePoints) {
        const positions = threePoints.geometry.attributes.position.array;
        let xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, zMin = Infinity, zMax = -Infinity;
        for (const f of features) {
            if (f.x3 < xMin) xMin = f.x3; if (f.x3 > xMax) xMax = f.x3;
            if (f.y3 < yMin) yMin = f.y3; if (f.y3 > yMax) yMax = f.y3;
            if (f.z3 < zMin) zMin = f.z3; if (f.z3 > zMax) zMax = f.z3;
        }
        const cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cz = (zMin + zMax) / 2;
        const range = Math.max(xMax - xMin, yMax - yMin, zMax - zMin) || 1;
        const scale3d = 20.0 / range;
        for (let i = 0; i < features.length; i++) {
            const f = features[i];
            positions[i * 3] = (f.x3 - cx) * scale3d;
            positions[i * 3 + 1] = (f.y3 - cy) * scale3d;
            positions[i * 3 + 2] = (f.z3 - cz) * scale3d;
        }
        threePoints.geometry.attributes.position.needsUpdate = true;
        updateThreeColors();
    }
});

// Glow slider
const glowSlider = document.getElementById("glow-slider");
const glowVal = document.getElementById("glow-val");
glowSlider.addEventListener("input", () => {
    const v = parseInt(glowSlider.value) / 100;
    glowVal.textContent = v.toFixed(1);
    if (threePoints) threePoints.material.uniforms.glowIntensity.value = v;
});

// === Canvas sizing ===
function resize() {
    const rect = canvas.parentElement.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    canvas.style.width = rect.width + "px";
    canvas.style.height = rect.height + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function resetView() {
    const rect = canvas.parentElement.getBoundingClientRect();
    const w = rect.width, h = rect.height;
    const dataW = dataXMax - dataXMin, dataH = dataYMax - dataYMin;
    viewScale = Math.min(w / dataW, h / dataH) * 0.9;
    viewX = w / 2 - (dataXMin + dataW / 2) * viewScale;
    viewY = h / 2 + (dataYMin + dataH / 2) * viewScale;
}

function worldToScreen(wx, wy) { return [wx * viewScale + viewX, -wy * viewScale + viewY]; }
function screenToWorld(sx, sy) { return [(sx - viewX) / viewScale, -(sy - viewY) / viewScale]; }

// === Color helpers ===
function isDarkMode() { return document.documentElement.getAttribute("data-theme") === "dark"; }

function hslToRgb(h, s, l) {
    const c = (1 - Math.abs(2 * l - 1)) * s;
    const h6 = h * 6;
    const x = c * (1 - Math.abs((h6 % 2) - 1));
    const m = l - c / 2;
    let r, g, b;
    const sector = Math.floor(h6) % 6;
    if (sector === 0) { r = c; g = x; b = 0; }
    else if (sector === 1) { r = x; g = c; b = 0; }
    else if (sector === 2) { r = 0; g = c; b = x; }
    else if (sector === 3) { r = 0; g = x; b = c; }
    else if (sector === 4) { r = x; g = 0; b = c; }
    else { r = c; g = 0; b = x; }
    return [r + m, g + m, b + m];
}

function hexToRgb(hex) {
    const r = parseInt(hex.slice(1, 3), 16) / 255;
    const g = parseInt(hex.slice(3, 5), 16) / 255;
    const b = parseInt(hex.slice(5, 7), 16) / 255;
    return [r, g, b];
}

// Get color for a feature based on colorMode
function featureColorHSL(f) {
    const dR = f._rd || 0;
    const mR = f._rm || 0;
    const xR = f._rx || 0;

    if (colorMode === "category") {
        const hex = categoryColorMap[f.cat] || "#bdc3c7";
        const [r, g, b] = hexToRgb(hex);
        // Return as pseudo-HSL that works with our RGB pipeline
        return { rgb: [r, g, b] };
    } else if (colorMode === "scheming") {
        // Blue(0) -> Red(10) by scheming score
        const t = Math.min(1, (f.sc || 0) / 10);
        const h = 0.65 - t * 0.65; // blue -> red
        const s = 0.5 + t * 0.4;
        const l = 0.3 + t * 0.3;
        return [h, s, l];
    } else if (colorMode === "probe") {
        // Dim grey -> bright gold by probe weight magnitude
        const pw = Math.abs(f.pw || 0);
        if (pw < 0.001) return [0, 0, 0.25]; // grey
        const t = Math.min(1, pw * 5); // scale to visible range
        const h = 0.12; // gold hue
        const s = 0.4 + t * 0.5;
        const l = 0.3 + t * 0.4;
        return [h, s, l];
    } else if (colorMode === "af_fraction") {
        // Blue(aligned, 0) -> Red(all AF, 1)
        const t = f.af || 0;
        const h = 0.65 - t * 0.65;
        const s = 0.5 + t * 0.3;
        const l = 0.3 + t * 0.25;
        return [h, s, l];
    } else if (colorMode === "position") {
        const hue = (Math.atan2(f.y, f.x) + Math.PI) / (2 * Math.PI);
        return [hue, 0.7, 0.35 + dR * 0.3];
    } else if (colorMode === "density") {
        return [0.65 - dR * 0.65, 0.7, 0.35 + dR * 0.25];
    } else if (colorMode === "mean") {
        return [0.65 - mR * 0.65, 0.75, 0.35 + mR * 0.25];
    } else if (colorMode === "max") {
        return [0.65 - xR * 0.65, 0.75, 0.35 + xR * 0.25];
    } else { // act+density
        const hue = 0.65 - mR * 0.65;
        const sat = 0.3 + dR * 0.6;
        const light = 0.3 + mR * 0.2 + dR * 0.15;
        return [hue, sat, light];
    }
}

function featureRainbowCSS(f, alpha) {
    const color = featureColorHSL(f);
    let r, g, b;
    if (color.rgb) {
        [r, g, b] = color.rgb;
    } else {
        [r, g, b] = hslToRgb(color[0], color[1], color[2]);
    }
    return `rgba(${Math.round(r*255)},${Math.round(g*255)},${Math.round(b*255)},${alpha})`;
}

// === Drawing ===
let hoverHighlightSet = null;
let inferHighlightSet = null;

function draw() {
    if (viewMode === "3d") { updateThreeColors(); return; }

    const rect = canvas.parentElement.getBoundingClientRect();
    const w = rect.width, h = rect.height;
    const dark = isDarkMode();

    ctx.fillStyle = dark ? "#1a1a1a" : "#F3EDE3";
    ctx.fillRect(0, 0, w, h);

    const activeHighlight = (hoverHighlightSet && hoverHighlightSet.size > 0) ? hoverHighlightSet
        : (inferHighlightSet && inferHighlightSet.size > 0) ? inferHighlightSet
        : highlightSet;
    const hasHighlight = activeHighlight && activeHighlight.size > 0;
    const hasFocusHighlight = (inferHighlightSet && inferHighlightSet.size > 0)
        || (highlightSet && highlightSet.size > 0);

    for (const f of features) {
        const [sx, sy] = worldToScreen(f.x, f.y);
        if (sx < -10 || sx > w + 10 || sy < -10 || sy > h + 10) continue;

        const isHighlighted = hasHighlight && activeHighlight.has(f.i);
        const isSelected = f.i === selectedIdx;

        let r, alpha;
        const logD = Math.log10(Math.max(f.d, 1e-6));
        const t = Math.max(0, Math.min(1, (logD + 5) / 3.5));
        alpha = 0.15 + t * 0.65;
        r = 1.5 + t * 2.5;

        // Probe weight sizing
        if (probeWeightSizing && f.pw) {
            const pwMag = Math.abs(f.pw);
            if (pwMag > 0.001) {
                r = r * (1 + Math.min(3, pwMag * 10));
            }
        }

        // Unclassified features are smaller/dimmer in category mode
        if (colorMode === "category" && f.cat === "unclassified" && !isHighlighted && !isSelected) {
            r *= 0.6;
            alpha *= 0.3;
        }

        if (isSelected) {
            r = 6;
            ctx.beginPath();
            ctx.arc(sx, sy, r + 3, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(220, 160, 40, 0.25)";
            ctx.fill();
        }

        if (hasFocusHighlight && !isHighlighted && !isSelected) {
            alpha = Math.max(alpha * 0.4, 0.1);
            r = Math.max(r * 0.8, 1.5);
        }

        if (isHighlighted && inferHighlightSet && inferHighlightSet.size > 0) {
            r = Math.max(r, 5);
        }

        ctx.beginPath();
        ctx.arc(sx, sy, r, 0, Math.PI * 2);

        const isHoverHL = hoverHighlightSet && hoverHighlightSet.size > 0 && hoverHighlightSet.has(f.i);
        const isInferHL = inferHighlightSet && inferHighlightSet.size > 0 && inferHighlightSet.has(f.i);
        const isSearchHL = highlightSet && highlightSet.size > 0 && highlightSet.has(f.i);

        if (isSelected) {
            ctx.fillStyle = "rgba(220, 160, 40, 1)";
        } else if (isHoverHL) {
            ctx.fillStyle = featureRainbowCSS(f, Math.min(1, alpha + 0.4));
        } else if (isInferHL || isSearchHL) {
            ctx.fillStyle = `rgba(220, 160, 40, ${Math.min(1, alpha + 0.3)})`;
        } else {
            ctx.fillStyle = featureRainbowCSS(f, alpha);
        }
        ctx.fill();

        // Ring around labeled features
        if (!isSelected && !isHoverHL && !isInferHL && !isSearchHL && featureLabels[f.i] && featureLabels[f.i].interp) {
            ctx.beginPath();
            ctx.arc(sx, sy, r + 1.5, 0, Math.PI * 2);
            ctx.strokeStyle = dark
                ? `rgba(255, 255, 255, ${Math.min(1, alpha + 0.15)})`
                : `rgba(40, 40, 40, ${Math.min(1, alpha + 0.15)})`;
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    }

    // Draw neighbor lines
    if (selectedIdx !== null && neighborData && neighborData.length > 0) {
        const selFeat = features.find(f => f.i === selectedIdx);
        if (selFeat) {
            const [sx, sy] = worldToScreen(selFeat.x, selFeat.y);
            for (const n of neighborData) {
                const [nx, ny] = worldToScreen(n.x, n.y);
                const lineAlpha = 0.15 + n.sim * 0.5;
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(nx, ny);
                ctx.strokeStyle = `rgba(220, 160, 40, ${lineAlpha})`;
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(nx, ny, 4, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(220, 160, 40, 0.7)`;
                ctx.fill();
            }
        }
    }
}

// === Interaction: Pan & Zoom ===
let isPanning = false;
let panStartX, panStartY;

canvas.addEventListener("mousedown", (e) => {
    if (e.button === 0) {
        isPanning = true;
        panStartX = e.clientX;
        panStartY = e.clientY;
        canvas.style.cursor = "grabbing";
    }
});

window.addEventListener("mousemove", (e) => {
    if (isPanning) {
        viewX += e.clientX - panStartX;
        viewY += e.clientY - panStartY;
        panStartX = e.clientX;
        panStartY = e.clientY;
        draw();
    }
});

window.addEventListener("mouseup", () => {
    isPanning = false;
    canvas.style.cursor = "crosshair";
});

canvas.addEventListener("wheel", (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const factor = e.deltaY > 0 ? 0.9 : 1.1;
    viewX = mx - (mx - viewX) * factor;
    viewY = my - (my - viewY) * factor;
    viewScale *= factor;
    draw();
}, { passive: false });

// === Interaction: Click & Hover ===
let clickStart = null;
let canvasHoverIdx = null;

canvas.addEventListener("mousedown", (e) => {
    clickStart = { x: e.clientX, y: e.clientY, time: Date.now() };
});

canvas.addEventListener("mouseup", async (e) => {
    if (!clickStart) return;
    const dx = e.clientX - clickStart.x;
    const dy = e.clientY - clickStart.y;
    const dt = Date.now() - clickStart.time;
    clickStart = null;
    if (Math.abs(dx) > 5 || Math.abs(dy) > 5 || dt > 300) return;

    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const closest = findClosest(mx, my, 8);
    if (closest) {
        selectedIdx = closest.i;
        draw();
        await showFeature(closest.i);
    } else {
        selectedIdx = null;
        neighborData = null;
        highlightSet = null;
        searchResults = null;
        searchInput.value = "";
        searchStatus.textContent = "";
        draw();
    }
});

canvas.addEventListener("mousemove", (e) => {
    if (isPanning) return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const closest = findClosest(mx, my, 8);
    if (closest) {
        tooltip.style.display = "block";
        tooltip.style.left = (e.clientX + 14) + "px";
        tooltip.style.top = (e.clientY + 14) + "px";
        const label = featureLabels[closest.i];
        const interpStr = label && label.interp ? `<div class="tt-interp">${escapeHtml(label.interp.substring(0, 100))}${label.interp.length > 100 ? '...' : ''}</div>` : '';
        const catColor = categoryColorMap[closest.cat] || '#bdc3c7';
        const catStr = closest.cat && closest.cat !== 'unclassified' ? `<div class="tt-cat" style="background:${catColor}">${closest.cat.replace(/_/g, ' ')}</div>` : '';
        tooltip.innerHTML = `<div class="tt-idx">Feature #${closest.i}</div>` +
            interpStr + catStr +
            `<div class="tt-stats">density: ${(closest.d * 100).toFixed(2)}% | AF: ${(closest.af * 100).toFixed(0)}% | scheming: ${closest.sc}</div>`;
        canvas.style.cursor = "pointer";
        if (canvasHoverIdx !== closest.i) {
            canvasHoverIdx = closest.i;
            hoverHighlightSet = new Set([closest.i]);
            draw();
        }
    } else {
        tooltip.style.display = "none";
        if (!isPanning) canvas.style.cursor = "crosshair";
        if (canvasHoverIdx !== null) {
            canvasHoverIdx = null;
            hoverHighlightSet = null;
            draw();
        }
    }
});

canvas.addEventListener("mouseleave", () => {
    tooltip.style.display = "none";
    if (canvasHoverIdx !== null) {
        canvasHoverIdx = null;
        hoverHighlightSet = null;
        draw();
    }
});

function findClosest(sx, sy, maxDist) {
    let best = null, bestDist = Infinity;
    for (const f of features) {
        const [fx, fy] = worldToScreen(f.x, f.y);
        const d = Math.hypot(sx - fx, sy - fy);
        if (d < bestDist && d < maxDist) { best = f; bestDist = d; }
    }
    return best;
}

// === Sidebar ===
let neighborData = null;

async function showFeature(idx) {
    sidebar.classList.remove("collapsed");
    sidebarBody.innerHTML = '<div class="loading"><div class="spinner"></div><br>Loading...</div>';
    neighborData = null;
    updateThreeNeighborLines();
    draw();

    try {
        const [featureResp, neighborsResp] = await Promise.all([
            fetch(`/api/feature/${idx}`),
            fetch(`/api/neighbors/${idx}`),
        ]);
        const data = await featureResp.json();
        const nbrs = await neighborsResp.json();

        neighborData = nbrs.neighbors || [];
        updateThreeNeighborLines();
        draw();

        renderFeature(data, neighborData);
    } catch (e) {
        sidebarBody.innerHTML = `<div class="loading">Error: ${e.message}</div>`;
    }
}

function updateThreeNeighborLines() {
    if (viewMode !== "3d" || !threeScene) return;
    const old = threeScene.getObjectByName("neighborLines");
    if (old) threeScene.remove(old);
    if (selectedIdx === null || !neighborData || neighborData.length === 0) return;

    const positions = threePoints.geometry.attributes.position.array;
    const selArrayIdx = features.findIndex(f => f.i === selectedIdx);
    if (selArrayIdx < 0) return;
    const sx = positions[selArrayIdx * 3], sy = positions[selArrayIdx * 3 + 1], sz = positions[selArrayIdx * 3 + 2];

    const linePositions = [];
    const lineColors = [];
    for (const n of neighborData) {
        const nArrayIdx = features.findIndex(f => f.i === n.i);
        if (nArrayIdx < 0) continue;
        const nx = positions[nArrayIdx * 3], ny = positions[nArrayIdx * 3 + 1], nz = positions[nArrayIdx * 3 + 2];
        linePositions.push(sx, sy, sz, nx, ny, nz);
        const alpha = 0.4 + n.sim * 0.6;
        lineColors.push(0.5*alpha, 0.6*alpha, 0.8*alpha, 0.5*alpha, 0.6*alpha, 0.8*alpha);
    }

    if (linePositions.length > 0) {
        const lineGeo = new THREE.BufferGeometry();
        lineGeo.setAttribute("position", new THREE.Float32BufferAttribute(linePositions, 3));
        lineGeo.setAttribute("color", new THREE.Float32BufferAttribute(lineColors, 3));
        const lineMat = new THREE.LineBasicMaterial({
            vertexColors: true, transparent: true, opacity: 0.5,
            depthTest: true, blending: THREE.AdditiveBlending, depthWrite: false,
        });
        const lines = new THREE.LineSegments(lineGeo, lineMat);
        lines.name = "neighborLines";
        threeScene.add(lines);
    }
}

function renderFeature(data, neighbors) {
    const label = featureLabels[data.feature_idx] || {};
    const interpVal = label.interp || "";
    let html = "";

    html += `<div class="feature-title">Feature <span class="idx">#${data.feature_idx}</span></div>`;

    // Category badge
    if (data.category && data.category !== "unclassified") {
        const catColor = categoryColorMap[data.category] || "#bdc3c7";
        html += `<div style="margin:4px 0 8px"><span class="cat-badge" style="background:${catColor}">${data.category.replace(/_/g, ' ')}</span></div>`;
    }

    // LLM description
    if (data.description) {
        html += `<div style="background:var(--hover-bg);border-radius:8px;padding:10px 12px;margin-bottom:12px;font-size:12px;line-height:1.6;border-left:3px solid var(--accent)">${escapeHtml(data.description)}</div>`;
    }

    // Editable interpretation
    html += `<div class="interp-box">
        <input type="text" class="interp-input" id="interp-input" value="${escapeHtml(interpVal)}" placeholder="Label this feature..." data-feature="${data.feature_idx}">
        <button class="interp-save" id="interp-save">Save</button>
    </div>`;

    // Stats grid with AF fields
    html += `<div class="stats-grid">
        <div class="stat-card">
            <div class="stat-label">AF Fraction</div>
            <div class="stat-value">${(data.af_fraction * 100).toFixed(1)}%</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Scheming Score</div>
            <div class="stat-value">${data.scheming_score}/10</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Probe Weight</div>
            <div class="stat-value">${data.probe_weight.toFixed(4)}</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Cluster</div>
            <div class="stat-value">${data.cluster_id >= 0 ? '#' + data.cluster_id : 'none'}</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Density</div>
            <div class="stat-value">${(data.density * 100).toFixed(3)}%</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Max Activation</div>
            <div class="stat-value">${data.max_act.toFixed(1)}</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Mean Activation</div>
            <div class="stat-value">${data.mean_act.toFixed(1)}</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Fire Count</div>
            <div class="stat-value">${data.fire_count.toLocaleString()}</div>
        </div>
    </div>`;

    // Neighbors
    if (neighbors.length > 0) {
        html += `<div class="examples-header">Most Similar Features</div>`;
        html += `<div style="margin-bottom:12px">`;
        for (const n of neighbors.slice(0, 10)) {
            const nFeat = features.find(f => f.i === n.i);
            const nCat = nFeat ? nFeat.cat : "";
            const nColor = categoryColorMap[nCat] || "#bdc3c7";
            const catTag = nCat && nCat !== "unclassified" ? `<span class="cat-badge" style="background:${nColor};font-size:9px;padding:1px 4px">${nCat.replace(/_/g,' ')}</span>` : '';
            html += `<div class="search-result-item" data-idx="${n.i}" style="padding:4px 8px">
                <span class="feat-idx">#${n.i} ${catTag}</span>
                <div class="feat-bar"><div class="feat-bar-fill" style="width:${(n.sim * 100).toFixed(0)}%"></div></div>
                <span class="feat-score">${n.sim.toFixed(3)}</span>
            </div>`;
        }
        html += `</div>`;
    }

    sidebarBody.innerHTML = html;

    // Click handlers
    for (const el of sidebarBody.querySelectorAll(".search-result-item")) {
        el.addEventListener("click", async () => {
            const nIdx = parseInt(el.dataset.idx);
            selectedIdx = nIdx;
            draw();
            await showFeature(nIdx);
        });
    }

    // Interp save handler
    const interpInput = document.getElementById("interp-input");
    const interpSave = document.getElementById("interp-save");
    if (interpInput && interpSave) {
        const saveInterp = async () => {
            const featIdx = parseInt(interpInput.dataset.feature);
            const val = interpInput.value.trim();
            interpSave.textContent = "...";
            interpSave.disabled = true;
            try {
                await fetch(`/api/label/${featIdx}`, {
                    method: "POST",
                    headers: {"Content-Type": "application/json"},
                    body: JSON.stringify({interp: val}),
                });
                if (!featureLabels[featIdx]) featureLabels[featIdx] = {interp: "", autointerp: ""};
                featureLabels[featIdx].interp = val;
                interpSave.textContent = "Saved";
                setTimeout(() => { interpSave.textContent = "Save"; interpSave.disabled = false; }, 800);
            } catch (e) {
                interpSave.textContent = "Error";
                setTimeout(() => { interpSave.textContent = "Save"; interpSave.disabled = false; }, 1500);
            }
        };
        interpSave.addEventListener("click", saveInterp);
        interpInput.addEventListener("keydown", (e) => { if (e.key === "Enter") saveInterp(); });
    }
}

function escapeHtml(s) {
    if (!s) return "";
    return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;").replace(/'/g, "&#39;");
}

function interpTag(featureIdx) {
    const label = featureLabels[featureIdx];
    if (label && label.interp) return ` <span style="font-weight:700;font-style:italic;color:var(--accent);font-size:inherit">${escapeHtml(label.interp.substring(0, 60))}</span>`;
    return '';
}

document.getElementById("sidebar-close").addEventListener("click", () => {
    sidebar.classList.add("collapsed");
    selectedIdx = null;
    neighborData = null;
    inferHighlightSet = null;
    draw();
});

// === Search ===
let searchTimeout = null;

searchInput.addEventListener("input", () => {
    clearTimeout(searchTimeout);
    const q = searchInput.value.trim();
    if (q.length < 2) {
        highlightSet = null;
        searchResults = null;
        searchStatus.textContent = "";
        draw();
        return;
    }

    searchTimeout = setTimeout(async () => {
        try {
            searchStatus.textContent = "Searching...";
            const resp = await fetch(`/api/search?q=${encodeURIComponent(q)}`);
            const data = await resp.json();

            if (data.features && data.features.length > 0) {
                highlightSet = new Set(data.features.map(f => f.i));
                searchResults = data.features;
                searchStatus.textContent = `${data.features.length} features`;
                draw();
                showSearchResults(data);
            } else {
                highlightSet = null;
                searchResults = null;
                searchStatus.textContent = "No matches";
                draw();
            }
        } catch (e) {
            searchStatus.textContent = "Search error";
        }
    }, 300);
});

function showSearchResults(data) {
    sidebar.classList.remove("collapsed");
    const maxScore = data.features[0]?.s || 1;

    let html = `<div class="feature-title">Search: "${escapeHtml(data.query)}"</div>`;
    html += `<div style="font-size:12px;color:var(--text-secondary);margin-bottom:12px">${data.features.length} matching features</div>`;
    html += `<div class="examples-header">Results</div>`;
    html += `<div class="search-results">`;

    for (const f of data.features.slice(0, 30)) {
        const pct = (f.s / maxScore * 100).toFixed(0);
        const feat = features.find(ft => ft.i === f.i);
        const cat = feat ? feat.cat : "";
        const catColor = categoryColorMap[cat] || "#bdc3c7";
        const catTag = cat && cat !== "unclassified" ? `<span class="cat-badge" style="background:${catColor};font-size:9px;padding:1px 4px">${cat.replace(/_/g,' ')}</span>` : '';
        html += `<div class="search-result-item" data-idx="${f.i}">
            <span class="feat-idx">#${f.i} ${catTag}</span>
            <div class="feat-bar"><div class="feat-bar-fill" style="width:${pct}%"></div></div>
            <span class="feat-score">${f.s.toFixed(1)}</span>
        </div>`;
    }

    html += `</div>`;
    sidebarBody.innerHTML = html;

    for (const el of sidebarBody.querySelectorAll(".search-result-item")) {
        el.addEventListener("click", async () => {
            const idx = parseInt(el.dataset.idx);
            selectedIdx = idx;
            draw();
            await showFeature(idx);
        });
    }
}

// === Color mode toggle ===
document.getElementById("color-mode").addEventListener("change", (e) => {
    colorMode = e.target.value;
    probeWeightSizing = (colorMode === "probe");
    updateLegendVisibility();
    draw();
});

// === Theme toggle ===
const themeToggle = document.getElementById("theme-toggle");
const savedTheme = localStorage.getItem("sae-theme");
if (savedTheme === "dark") {
    document.documentElement.setAttribute("data-theme", "dark");
    themeToggle.textContent = "Light";
    themeToggle.classList.add("active");
}

themeToggle.addEventListener("click", () => {
    const isDark = document.documentElement.getAttribute("data-theme") === "dark";
    if (isDark) {
        document.documentElement.removeAttribute("data-theme");
        themeToggle.textContent = "Dark";
        themeToggle.classList.remove("active");
        localStorage.setItem("sae-theme", "light");
    } else {
        document.documentElement.setAttribute("data-theme", "dark");
        themeToggle.textContent = "Light";
        themeToggle.classList.add("active");
        localStorage.setItem("sae-theme", "dark");
    }
    draw();
});

// === Story Mode ===
const storyPanel = document.getElementById("story-panel");
const storyToggle = document.getElementById("story-toggle");
const storyBody = document.getElementById("story-body");
const storyChapterLabel = document.getElementById("story-chapter-label");
const storyDotsEl = document.getElementById("story-dots");
const storyPrev = document.getElementById("story-prev");
const storyNext = document.getElementById("story-next");

storyToggle.addEventListener("click", () => {
    const visible = storyPanel.classList.toggle("visible");
    storyToggle.classList.toggle("active", visible);
    if (visible) {
        renderStoryChapter();
    }
});

document.getElementById("story-close").addEventListener("click", () => {
    storyPanel.classList.remove("visible");
    storyToggle.classList.remove("active");
});

storyPrev.addEventListener("click", () => {
    if (storyChapter > 0) { storyChapter--; renderStoryChapter(); }
});

storyNext.addEventListener("click", () => {
    if (storyChapter < storyData.length - 1) { storyChapter++; renderStoryChapter(); }
});

function renderStoryChapter() {
    if (!storyData.length) return;
    const ch = storyData[storyChapter];

    storyChapterLabel.textContent = `Chapter ${ch.chapter} of ${storyData.length}`;
    storyBody.innerHTML = `<h2>${escapeHtml(ch.title)}</h2>
        <div class="subtitle">${escapeHtml(ch.subtitle)}</div>
        <div class="narrative">${ch.narrative}</div>`;

    // Update dots
    storyDotsEl.innerHTML = "";
    for (let i = 0; i < storyData.length; i++) {
        const dot = document.createElement("div");
        dot.className = "story-dot" + (i === storyChapter ? " active" : "");
        dot.addEventListener("click", () => { storyChapter = i; renderStoryChapter(); });
        storyDotsEl.appendChild(dot);
    }

    // Update nav
    storyPrev.disabled = storyChapter === 0;
    storyNext.disabled = storyChapter === storyData.length - 1;

    // Apply chapter settings
    if (ch.colorMode) {
        colorMode = ch.colorMode;
        document.getElementById("color-mode").value = colorMode;
        probeWeightSizing = (colorMode === "probe") || ch.showProbeWeights;
        updateLegendVisibility();
    }

    if (ch.highlightFeatures && ch.highlightFeatures.length > 0) {
        highlightSet = new Set(ch.highlightFeatures);
    } else {
        highlightSet = null;
    }

    if (ch.showLegend) {
        document.getElementById("legend-panel").classList.add("visible");
    }

    draw();
}

// === Sample Viewer ===
const samplePanel = document.getElementById("sample-panel");
const sampleToggle = document.getElementById("sample-toggle");
const sampleBody = document.getElementById("sample-body");
const sampleIdxEl = document.getElementById("sample-idx");

sampleToggle.addEventListener("click", () => {
    const visible = samplePanel.classList.toggle("visible");
    sampleToggle.classList.toggle("active", visible);
    if (visible) renderSample();
});

document.getElementById("sample-prev").addEventListener("click", () => {
    if (sampleIdx > 0) { sampleIdx--; renderSample(); }
});

document.getElementById("sample-next").addEventListener("click", () => {
    if (sampleIdx < samplesData.length - 1) { sampleIdx++; renderSample(); }
});

function renderSample() {
    if (!samplesData.length) { sampleBody.innerHTML = "No samples loaded."; return; }
    const s = samplesData[sampleIdx];
    sampleIdxEl.textContent = `${sampleIdx + 1}/${samplesData.length}`;

    let html = `<div style="display:flex;align-items:center;gap:8px;margin-bottom:8px">
        <span class="severity-badge severity-${s.severity}">${s.severity}</span>
        <span style="font-family:var(--mono);font-size:13px;font-weight:600">Score: ${s.score.toFixed(3)}</span>
        <span style="font-size:11px;color:var(--text-muted)">${s.dataset} | ${s.true_label}</span>
    </div>`;

    // Category breakdown bar
    if (s.category_breakdown) {
        const total = Object.values(s.category_breakdown).reduce((a, b) => a + b, 0);
        if (total > 0) {
            html += `<div class="cat-breakdown">`;
            for (const [cat, count] of Object.entries(s.category_breakdown).sort((a, b) => b[1] - a[1])) {
                const pct = (count / total * 100).toFixed(1);
                const color = categoryColorMap[cat] || "#bdc3c7";
                html += `<div style="width:${pct}%;background:${color}" title="${cat.replace(/_/g,' ')}: ${count} (${pct}%)"></div>`;
            }
            html += `</div>`;

            html += `<div style="display:flex;flex-wrap:wrap;gap:3px;margin-bottom:8px">`;
            for (const [cat, count] of Object.entries(s.category_breakdown).sort((a, b) => b[1] - a[1])) {
                const color = categoryColorMap[cat] || "#bdc3c7";
                html += `<span class="cat-badge" style="background:${color}">${cat.replace(/_/g,' ')} ${count}</span>`;
            }
            html += `</div>`;
        }
    }

    // Top features
    if (s.top_features && s.top_features.length > 0) {
        html += `<div class="examples-header">Top Features</div>`;
        for (const tf of s.top_features) {
            const catColor = categoryColorMap[tf.category] || "#bdc3c7";
            html += `<div class="search-result-item" data-idx="${tf.id}" style="padding:4px 6px">
                <span class="feat-idx">#${tf.id}</span>
                <span class="cat-badge" style="background:${catColor};font-size:9px;padding:1px 4px">${(tf.category || '').replace(/_/g,' ')}</span>
                <span class="feat-score">${tf.activation.toFixed(0)}</span>
            </div>`;
        }

        // Highlight top features on UMAP
        highlightSet = new Set(s.top_features.map(tf => tf.id));
        draw();
    }

    // Stats
    html += `<div style="margin-top:8px;font-size:11px;color:var(--text-muted)">
        Intent: ${s.n_intent} | Self-pres: ${s.n_self_preservation} | RLHF: ${s.n_rlhf_awareness}
    </div>`;

    sampleBody.innerHTML = html;

    // Click handlers
    for (const el of sampleBody.querySelectorAll(".search-result-item")) {
        el.addEventListener("click", async () => {
            const idx = parseInt(el.dataset.idx);
            selectedIdx = idx;
            draw();
            await showFeature(idx);
        });
    }
}

// === 3D View (Three.js) ===
let viewMode = "2d";
let threeScene, threeCamera, threeRenderer, threePoints, threeRAF;
let threeContainer = document.getElementById("three-container");
let canvasContainer = document.getElementById("canvas-container");

let camQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(0.3, 0.5, 0));
let camPos = new THREE.Vector3(0, 0, 0);
let threeAutoRotate = false;
let threeHoverIdx = null;
const keysDown = new Set();
let flySpeed = 0.02;

let pointColors = null;
let pointSizes = null;
let pointOpacities = null;
let pointGlows = null;
let pointRings = null;

const viewToggle = document.getElementById("view-toggle");
viewToggle.addEventListener("click", () => {
    if (viewMode === "2d") {
        if (!features.some(f => f.x3 !== undefined)) {
            alert("3D coordinates not available.");
            return;
        }
        viewMode = "3d";
        viewToggle.textContent = "2D";
        viewToggle.classList.add("active");
        canvas.style.display = "none";
        threeContainer.style.display = "block";
        initThreeJS();
    } else {
        viewMode = "2d";
        viewToggle.textContent = "3D";
        viewToggle.classList.remove("active");
        canvas.style.display = "block";
        threeContainer.style.display = "none";
        if (threeRAF) cancelAnimationFrame(threeRAF);
        for (const idx in _proxLabelEls) { _proxLabelEls[idx].remove(); delete _proxLabelEls[idx]; }
        _proxLinesCtx.clearRect(0, 0, _proxLinesCanvas.width, _proxLinesCanvas.height);
        draw();
    }
});

function initThreeJS() {
    const rect = canvasContainer.getBoundingClientRect();
    const w = rect.width, h = rect.height;

    if (threeRenderer) {
        threeContainer.removeChild(threeRenderer.domElement);
        threeRenderer.dispose();
    }

    threeScene = new THREE.Scene();
    threeCamera = new THREE.PerspectiveCamera(60, w / h, 0.01, 200);
    threeRenderer = new THREE.WebGLRenderer({ antialias: true });
    threeRenderer.setSize(w, h);
    threeRenderer.setPixelRatio(window.devicePixelRatio || 1);
    threeContainer.appendChild(threeRenderer.domElement);

    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(features.length * 3);
    pointColors = new Float32Array(features.length * 3);
    pointSizes = new Float32Array(features.length);

    let xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, zMin = Infinity, zMax = -Infinity;
    for (const f of features) {
        if (f.x3 < xMin) xMin = f.x3; if (f.x3 > xMax) xMax = f.x3;
        if (f.y3 < yMin) yMin = f.y3; if (f.y3 > yMax) yMax = f.y3;
        if (f.z3 < zMin) zMin = f.z3; if (f.z3 > zMax) zMax = f.z3;
    }
    const cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cz = (zMin + zMax) / 2;
    const range = Math.max(xMax - xMin, yMax - yMin, zMax - zMin);
    const scale3d = 20.0 / range;

    for (let i = 0; i < features.length; i++) {
        const f = features[i];
        positions[i * 3] = (f.x3 - cx) * scale3d;
        positions[i * 3 + 1] = (f.y3 - cy) * scale3d;
        positions[i * 3 + 2] = (f.z3 - cz) * scale3d;
        pointColors[i * 3] = 0.545; pointColors[i * 3 + 1] = 0.616; pointColors[i * 3 + 2] = 0.514;
        pointSizes[i] = 1.0;
    }

    pointOpacities = new Float32Array(features.length).fill(1.0);
    pointGlows = new Float32Array(features.length).fill(0.0);
    pointRings = new Float32Array(features.length).fill(0.0);

    geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute("color", new THREE.BufferAttribute(pointColors, 3));
    geometry.setAttribute("size", new THREE.BufferAttribute(pointSizes, 1));
    geometry.setAttribute("opacity", new THREE.BufferAttribute(pointOpacities, 1));
    geometry.setAttribute("glow", new THREE.BufferAttribute(pointGlows, 1));
    geometry.setAttribute("ring", new THREE.BufferAttribute(pointRings, 1));

    const material = new THREE.ShaderMaterial({
        uniforms: {
            pointMultiplier: { value: Math.min(w, h) * 0.8 },
            fogNear: { value: 2.0 },
            fogFar: { value: 45.0 },
            glowIntensity: { value: 1.0 },
        },
        vertexShader: `
            attribute float size;
            attribute float opacity;
            attribute float glow;
            attribute float ring;
            varying vec3 vColor;
            varying float vDepth;
            varying float vOpacity;
            varying float vGlow;
            varying float vRing;
            varying float vSize;
            uniform float pointMultiplier;
            void main() {
                vColor = color;
                vOpacity = opacity;
                vGlow = glow;
                vRing = ring;
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                float depth = -mvPosition.z;
                vDepth = depth;
                float s = size * pointMultiplier / (max(depth, 0.1) * max(depth, 0.1));
                if (glow > 0.0) s *= (1.0 + glow);
                if (s > 200.0) s = 200.0 + 40.0 * log(s / 200.0);
                gl_PointSize = max(s, 0.3);
                vSize = gl_PointSize;
                gl_Position = projectionMatrix * mvPosition;
            }
        `,
        fragmentShader: `
            varying vec3 vColor;
            varying float vDepth;
            varying float vOpacity;
            varying float vGlow;
            varying float vRing;
            varying float vSize;
            uniform float fogNear;
            uniform float fogFar;
            uniform float glowIntensity;
            void main() {
                vec2 uv = gl_PointCoord - vec2(0.5);
                float d = length(uv);
                if (d > 0.5) discard;
                float fogFactor = 1.0 - clamp((vDepth - fogNear) / (fogFar - fogNear), 0.0, 0.9);
                vec3 col = vColor;
                float alpha;
                float inv = 1.0 / (1.0 + 2000.0 * d * d);
                float core = inv * inv * inv;
                float tail = 1.0 / (1.0 + 100.0 * d * d);
                float tailScale = (0.4 / (1.0 + vSize * 0.25) + 0.02) * glowIntensity;
                if (vGlow > 0.0) {
                    col = mix(col, vec3(1.0), core * vGlow * 0.4);
                    alpha = (core + tail * tailScale * 0.5) * fogFactor;
                } else {
                    col = mix(col, vec3(1.0), core);
                    alpha = (core + tail * tailScale) * fogFactor * vOpacity;
                }
                gl_FragColor = vec4(col, alpha);
            }
        `,
        vertexColors: true,
        transparent: true,
        depthWrite: false,
        depthTest: true,
        blending: THREE.AdditiveBlending,
    });

    threePoints = new THREE.Points(geometry, material);
    threeScene.add(threePoints);

    const _projVec = new THREE.Vector3();
    function findClosest3D(screenX, screenY, maxDist) {
        const positions = threePoints.geometry.attributes.position.array;
        const rect = threeRenderer.domElement.getBoundingClientRect();
        const hw = rect.width / 2, hh = rect.height / 2;
        let bestIdx = -1, bestDist = Infinity;
        for (let i = 0; i < features.length; i++) {
            _projVec.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);
            _projVec.project(threeCamera);
            if (_projVec.z > 1) continue;
            const sx = (_projVec.x * hw) + hw;
            const sy = (-_projVec.y * hh) + hh;
            const d = Math.hypot(screenX - sx, screenY - sy);
            if (d < bestDist && d < maxDist) { bestIdx = i; bestDist = d; }
        }
        return bestIdx >= 0 ? bestIdx : null;
    }

    const domEl = threeRenderer.domElement;

    domEl.addEventListener("mousedown", (e) => {
        if (e.button === 2 || e.button === 0) {
            if (!document.pointerLockElement) domEl.requestPointerLock();
            threeAutoRotate = false;
        }
    });
    domEl.addEventListener("contextmenu", (e) => e.preventDefault());
    window.addEventListener("mouseup", () => { if (document.pointerLockElement) document.exitPointerLock(); });
    document.addEventListener("pointerlockchange", () => { if (!document.pointerLockElement) domEl.style.cursor = "crosshair"; });

    window.addEventListener("mousemove", (e) => {
        if (document.pointerLockElement === domEl && viewMode === "3d") {
            threeCamera.updateMatrixWorld();
            const screenRight = new THREE.Vector3().setFromMatrixColumn(threeCamera.matrixWorld, 0).normalize();
            const sens = 0.003;
            const qYaw = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), -e.movementX * sens);
            const qPitch = new THREE.Quaternion().setFromAxisAngle(screenRight, -e.movementY * sens);
            camQuat.premultiply(qYaw).premultiply(qPitch).normalize();
        }
    });

    window.addEventListener("keydown", (e) => {
        if (viewMode !== "3d" || e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") return;
        const k = e.key.toLowerCase();
        if (["w","a","s","d","e","q"," ","shift","arrowup","arrowdown","arrowleft","arrowright"].includes(k)) {
            keysDown.add(k); threeAutoRotate = false; e.preventDefault();
        }
    });
    window.addEventListener("keyup", (e) => { keysDown.delete(e.key.toLowerCase()); });

    domEl.addEventListener("wheel", (e) => {
        e.preventDefault();
        flySpeed = e.deltaY < 0 ? Math.min(flySpeed * 1.3, 2.0) : Math.max(flySpeed / 1.3, 0.001);
    }, { passive: false });

    // Hover
    domEl.addEventListener("mousemove", (e) => {
        if (document.pointerLockElement) return;
        const rect = domEl.getBoundingClientRect();
        const idx = findClosest3D(e.clientX - rect.left, e.clientY - rect.top, 10);
        if (idx !== null) {
            const f = features[idx];
            domEl.style.cursor = "pointer";
            tooltip.style.display = "block";
            tooltip.style.left = (e.clientX + 14) + "px";
            tooltip.style.top = (e.clientY + 14) + "px";
            const catColor = categoryColorMap[f.cat] || '#bdc3c7';
            const catStr = f.cat && f.cat !== 'unclassified' ? `<div class="tt-cat" style="background:${catColor}">${f.cat.replace(/_/g, ' ')}</div>` : '';
            tooltip.innerHTML = `<div class="tt-idx">Feature #${f.i}</div>${catStr}<div class="tt-stats">AF: ${(f.af * 100).toFixed(0)}% | scheming: ${f.sc}</div>`;
            if (threeHoverIdx !== idx) { threeHoverIdx = idx; hoverHighlightSet = new Set([f.i]); updateThreeColors(); }
        } else {
            tooltip.style.display = "none";
            if (!document.pointerLockElement) domEl.style.cursor = "crosshair";
            if (threeHoverIdx !== null) { threeHoverIdx = null; hoverHighlightSet = null; updateThreeColors(); }
        }
    });

    domEl.addEventListener("mouseleave", () => {
        tooltip.style.display = "none";
        if (threeHoverIdx !== null) { threeHoverIdx = null; hoverHighlightSet = null; updateThreeColors(); }
    });

    // Click
    let threeClickStart = null;
    domEl.addEventListener("mousedown", (e) => { threeClickStart = { x: e.clientX, y: e.clientY, time: Date.now() }; });
    domEl.addEventListener("mouseup", async (e) => {
        if (!threeClickStart) return;
        const dx = e.clientX - threeClickStart.x, dy = e.clientY - threeClickStart.y;
        const dt = Date.now() - threeClickStart.time;
        threeClickStart = null;
        if (Math.abs(dx) > 5 || Math.abs(dy) > 5 || dt > 300) return;
        const rect = domEl.getBoundingClientRect();
        const idx = findClosest3D(e.clientX - rect.left, e.clientY - rect.top, 10);
        if (idx !== null) {
            selectedIdx = features[idx].i;
            updateThreeColors();
            await showFeature(features[idx].i);
        } else {
            selectedIdx = null; neighborData = null; highlightSet = null;
            searchInput.value = ""; searchStatus.textContent = "";
            updateThreeColors();
        }
    });

    updateThreeColors();
    threeAnimate();
}

function updateThreeColors() {
    if (!threePoints || viewMode !== "3d") return;
    const pos = threePoints.geometry.attributes.position.array;

    const activeHighlight = (hoverHighlightSet && hoverHighlightSet.size > 0) ? hoverHighlightSet
        : (inferHighlightSet && inferHighlightSet.size > 0) ? inferHighlightSet
        : highlightSet;
    const hasHighlight = activeHighlight && activeHighlight.size > 0;
    const hasFocusHighlight = (inferHighlightSet && inferHighlightSet.size > 0)
        || (highlightSet && highlightSet.size > 0);

    for (let i = 0; i < features.length; i++) {
        const f = features[i];
        const isSelected = f.i === selectedIdx;
        const isHoverHL = hoverHighlightSet && hoverHighlightSet.size > 0 && hoverHighlightSet.has(f.i);
        const isInferHL = inferHighlightSet && inferHighlightSet.size > 0 && inferHighlightSet.has(f.i);
        const isSearchHL = highlightSet && highlightSet.size > 0 && highlightSet.has(f.i);

        let r, g, b;
        const color = featureColorHSL(f);
        if (color.rgb) {
            [r, g, b] = color.rgb;
        } else {
            if (colorMode === "position") {
                const px = pos[i * 3], py = pos[i * 3 + 1], pz = pos[i * 3 + 2];
                const h = (Math.atan2(pz, px) + Math.PI) / (2 * Math.PI);
                const s = 0.5 + Math.max(0, Math.min(1, (py + 2) / 4)) * 0.3;
                const logD = Math.log10(Math.max(f.d, 1e-6));
                const l = Math.max(0.3, Math.min(0.9, (logD + 5) / 4));
                [r, g, b] = hslToRgb(h, s, l);
            } else {
                [r, g, b] = hslToRgb(color[0], color[1], color[2]);
            }
        }

        let size = 1.0;
        let opacity = 1.0;
        let glowAmt = 0.0;

        // Probe weight sizing in 3D
        if (probeWeightSizing && f.pw) {
            const pwMag = Math.abs(f.pw);
            if (pwMag > 0.001) size = 1 + Math.min(3, pwMag * 10);
        }

        // Dim unclassified in category mode
        if (colorMode === "category" && f.cat === "unclassified" && !isSelected && !isHoverHL && !isInferHL && !isSearchHL) {
            opacity = 0.15;
            size *= 0.5;
        }

        if (isSelected) { r = 1.0; g = 1.0; b = 1.0; size = 3.0; glowAmt = 0.5; }
        else if (isHoverHL) { size = 2.5; glowAmt = 0.4; }
        else if (isInferHL || isSearchHL) { size = 2.0; glowAmt = 0.3; }

        pointColors[i * 3] = r; pointColors[i * 3 + 1] = g; pointColors[i * 3 + 2] = b;
        pointSizes[i] = size;
        pointOpacities[i] = opacity;
        pointGlows[i] = glowAmt;
    }

    threePoints.geometry.attributes.color.needsUpdate = true;
    threePoints.geometry.attributes.size.needsUpdate = true;
    threePoints.geometry.attributes.opacity.needsUpdate = true;
    threePoints.geometry.attributes.glow.needsUpdate = true;
}

function threeAnimate() {
    if (viewMode !== "3d") return;
    threeRAF = requestAnimationFrame(threeAnimate);

    if (threeAutoRotate && !document.pointerLockElement) {
        const angle = 0.001;
        const cos = Math.cos(angle), sin = Math.sin(angle);
        const x = camPos.x, z = camPos.z;
        camPos.x = x * cos - z * sin;
        camPos.z = x * sin + z * cos;
        const autoRot = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);
        camQuat.premultiply(autoRot).normalize();
    }

    const moveSpeed = flySpeed;
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camQuat);
    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camQuat);
    const up = new THREE.Vector3(0, 1, 0);
    if (keysDown.has("w") || keysDown.has("arrowup")) camPos.addScaledVector(forward, moveSpeed);
    if (keysDown.has("s") || keysDown.has("arrowdown")) camPos.addScaledVector(forward, -moveSpeed);
    if (keysDown.has("a") || keysDown.has("arrowleft")) camPos.addScaledVector(right, -moveSpeed);
    if (keysDown.has("d") || keysDown.has("arrowright")) camPos.addScaledVector(right, moveSpeed);
    if (keysDown.has("e") || keysDown.has(" ")) camPos.addScaledVector(up, moveSpeed);
    if (keysDown.has("q") || keysDown.has("shift")) camPos.addScaledVector(up, -moveSpeed);

    threeCamera.position.copy(camPos);
    threeCamera.quaternion.copy(camQuat);
    threeCamera.updateMatrixWorld();

    if (threePoints) {
        threePoints.material.uniforms.fogNear.value = 2.0;
        threePoints.material.uniforms.fogFar.value = 45.0;
    }

    threeScene.background = new THREE.Color(0x000000);
    threeRenderer.render(threeScene, threeCamera);
    updateProximityLabels();
}

const _proxLabelsContainer = document.getElementById("proximity-labels");
const _proxLinesCanvas = document.getElementById("proximity-lines");
const _proxLinesCtx = _proxLinesCanvas.getContext("2d");
const _proxLabelEls = {};
const _proxVec = new THREE.Vector3();
const PROX_FADE_NEAR = 0.2;
const PROX_FADE_FAR = 0.8;
const _proxLineData = [];

function updateProximityLabels() {
    if (!threePoints || viewMode !== "3d") return;
    const positions = threePoints.geometry.attributes.position.array;
    const rect = canvasContainer.getBoundingClientRect();
    const hw = rect.width / 2, hh = rect.height / 2;

    if (_proxLinesCanvas.width !== rect.width || _proxLinesCanvas.height !== rect.height) {
        _proxLinesCanvas.width = rect.width;
        _proxLinesCanvas.height = rect.height;
    }
    _proxLinesCtx.clearRect(0, 0, _proxLinesCanvas.width, _proxLinesCanvas.height);
    _proxLineData.length = 0;

    const active = new Set();

    for (let i = 0; i < features.length; i++) {
        const f = features[i];
        const label = featureLabels[f.i];
        if (!label || !label.interp) continue;

        _proxVec.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);
        const dist = camPos.distanceTo(_proxVec);

        if (dist > PROX_FADE_FAR) {
            if (_proxLabelEls[f.i]) _proxLabelEls[f.i].style.opacity = "0";
            continue;
        }

        _proxVec.project(threeCamera);
        if (_proxVec.z > 1) { if (_proxLabelEls[f.i]) _proxLabelEls[f.i].style.opacity = "0"; continue; }

        const sx = (1 + _proxVec.x) * hw;
        const sy = (1 - _proxVec.y) * hh;

        if (sx < -100 || sx > rect.width + 100 || sy < -50 || sy > rect.height + 50) {
            if (_proxLabelEls[f.i]) _proxLabelEls[f.i].style.opacity = "0";
            continue;
        }

        const opacity = 1.0 - Math.max(0, Math.min(1, (dist - PROX_FADE_NEAR) / (PROX_FADE_FAR - PROX_FADE_NEAR)));
        active.add(f.i);

        const pointMult = threePoints.material.uniforms.pointMultiplier.value;
        let starPx = pointMult / (Math.max(dist, 0.1) * Math.max(dist, 0.1));
        if (starPx > 200) starPx = 200 + 40 * Math.log(starPx / 200);
        const scale = Math.max(0.25, Math.min(0.8, starPx / 25));
        const offset = starPx * 0.08 + 2;

        let el = _proxLabelEls[f.i];
        if (!el) {
            el = document.createElement("div");
            el.className = "proximity-label";
            el.innerHTML = `<div class="pl-idx">Feature #${f.i}</div>`
                + `<div class="pl-interp">${escapeHtml(label.interp.substring(0, 80))}</div>`;
            _proxLabelsContainer.appendChild(el);
            _proxLabelEls[f.i] = el;
        }
        el.style.left = sx + "px";
        el.style.top = sy + "px";
        el.style.opacity = opacity.toFixed(2);
        el.style.borderColor = `rgba(255,255,255,${(opacity * 0.4).toFixed(2)})`;
        el.style.transform = `translate(${offset}px, -50%) scale(${scale.toFixed(2)})`;
        el.style.fontSize = "9px";

        _proxLineData.push({ sx, sy, lx: sx + offset * scale, ly: sy, opacity });
    }

    for (const idx in _proxLabelEls) {
        if (!active.has(Number(idx)) && _proxLabelEls[idx].style.opacity !== "0") {
            _proxLabelEls[idx].style.opacity = "0";
        }
    }

    for (const ld of _proxLineData) {
        _proxLinesCtx.beginPath();
        _proxLinesCtx.moveTo(ld.sx, ld.sy);
        _proxLinesCtx.lineTo(ld.lx, ld.ly);
        _proxLinesCtx.strokeStyle = `rgba(255, 255, 255, ${(ld.opacity * 0.3).toFixed(2)})`;
        _proxLinesCtx.lineWidth = 1;
        _proxLinesCtx.stroke();
    }
}

// === Resize handler ===
window.addEventListener("resize", () => {
    resize();
    if (viewMode === "2d") {
        draw();
    } else if (threeRenderer) {
        const rect = canvasContainer.getBoundingClientRect();
        threeCamera.aspect = rect.width / rect.height;
        threeCamera.updateProjectionMatrix();
        threeRenderer.setSize(rect.width, rect.height);
        threePoints.material.uniforms.pointMultiplier.value = Math.min(rect.width, rect.height) * 0.8;
    }
});

// === Init ===
init();
</script>
</body>
</html>
